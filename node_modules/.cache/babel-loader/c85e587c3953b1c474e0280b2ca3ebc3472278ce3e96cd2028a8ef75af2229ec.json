{"ast":null,"code":"// import React, {\n//   createContext,\n//   useContext,\n//   useReducer,\n//   useEffect,\n//   useCallback,\n//   useMemo,\n// } from \"react\";\n// import axios from \"axios\";\n// import { toast } from \"react-hot-toast\";\n// import { jwtDecode } from \"jwt-decode\";\n\n// const AuthContext = createContext();\n\n// const isTokenValid = (token) => {\n//   if (!token) return false;\n//   try {\n//     const decoded = jwtDecode(token);\n//     return decoded.exp * 1000 > Date.now();\n//   } catch (error) {\n//     return false;\n//   }\n// };\n\n// const token = localStorage.getItem(\"token\");\n// const user = token && isTokenValid(token) ? jwtDecode(token).user : null;\n\n// const initialState = {\n//   token: token,\n//   user: user,\n//   isAuthenticated: !!user,\n//   loading: false,\n//   error: null,\n// };\n\n// const AUTH_ACTIONS = {\n//   REQUEST_START: \"REQUEST_START\",\n//   AUTH_SUCCESS: \"AUTH_SUCCESS\",\n//   AUTH_FAILURE: \"AUTH_FAILURE\",\n//   LOGOUT: \"LOGOUT\",\n//   CLEAR_ERRORS: \"CLEAR_ERRORS\",\n// };\n\n// const authReducer = (state, action) => {\n//   switch (action.type) {\n//     case AUTH_ACTIONS.REQUEST_START:\n//       return { ...state, loading: true, error: null };\n//     case AUTH_ACTIONS.AUTH_SUCCESS:\n//       const newUser = jwtDecode(action.payload.token).user;\n//       localStorage.setItem(\"token\", action.payload.token);\n//       return {\n//         ...state,\n//         token: action.payload.token,\n//         user: newUser,\n//         isAuthenticated: true,\n//         loading: false,\n//         error: null,\n//       };\n//     case AUTH_ACTIONS.AUTH_FAILURE:\n//     case AUTH_ACTIONS.LOGOUT:\n//       localStorage.removeItem(\"token\");\n//       return {\n//         ...state,\n//         token: null,\n//         user: null,\n//         isAuthenticated: false,\n//         loading: false,\n//         error: action.payload,\n//       };\n//     case AUTH_ACTIONS.CLEAR_ERRORS:\n//       return { ...state, error: null };\n//     default:\n//       return state;\n//   }\n// };\n\n// export const AuthProvider = ({ children }) => {\n//   const [state, dispatch] = useReducer(authReducer, initialState);\n\n//   const login = useCallback(async (email, password) => {\n//     dispatch({ type: AUTH_ACTIONS.REQUEST_START });\n//     try {\n//       const response = await axios.post(\"/api/auth/login\", { email, password });\n//       dispatch({\n//         type: AUTH_ACTIONS.AUTH_SUCCESS,\n//         payload: { token: response.data.token },\n//       });\n//       toast.success(\"Logged in successfully!\");\n//       return { success: true };\n//     } catch (error) {\n//       const errorMessage = error.response?.data?.msg || \"Login failed\";\n//       dispatch({ type: AUTH_ACTIONS.AUTH_FAILURE, payload: errorMessage });\n//       toast.error(errorMessage);\n//       return { success: false, error: errorMessage };\n//     }\n//   }, []);\n\n//   const register = useCallback(async (userData) => {\n//     dispatch({ type: AUTH_ACTIONS.REQUEST_START });\n//     try {\n//       const response = await axios.post(\"/api/auth/register\", userData);\n//       dispatch({\n//         type: AUTH_ACTIONS.AUTH_SUCCESS,\n//         payload: { token: response.data.token },\n//       });\n//       toast.success(\"Account created successfully!\");\n//       return { success: true };\n//     } catch (error) {\n//       const errorMessage = error.response?.data?.msg || \"Registration failed\";\n//       dispatch({ type: AUTH_ACTIONS.AUTH_FAILURE, payload: errorMessage });\n//       toast.error(errorMessage);\n//       return { success: false, error: errorMessage };\n//     }\n//   }, []);\n\n//   const logout = useCallback(() => {\n//     dispatch({ type: AUTH_ACTIONS.LOGOUT, payload: null });\n//     toast.success(\"Logged out successfully!\");\n//   }, []);\n\n//   const clearErrors = useCallback(() => {\n//     dispatch({ type: AUTH_ACTIONS.CLEAR_ERRORS });\n//   }, []);\n\n//   useEffect(() => {\n//     if (state.token) {\n//       axios.defaults.headers.common[\"Authorization\"] = `Bearer ${state.token}`;\n//     } else {\n//       delete axios.defaults.headers.common[\"Authorization\"];\n//     }\n//   }, [state.token]);\n\n//   const value = useMemo(\n//     () => ({ ...state, login, register, logout, clearErrors }),\n//     [state, login, register, logout, clearErrors],\n//   );\n\n//   return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n// };\n\n// export const useAuth = () => {\n//   const context = useContext(AuthContext);\n//   if (!context) {\n//     throw new Error(\"useAuth must be used within an AuthProvider\");\n//   }\n//   return context;\n// };","map":{"version":3,"names":[],"sources":["/persistent/home/guddy/code/project/client/src/contexts/AuthContext.js"],"sourcesContent":["// import React, {\n//   createContext,\n//   useContext,\n//   useReducer,\n//   useEffect,\n//   useCallback,\n//   useMemo,\n// } from \"react\";\n// import axios from \"axios\";\n// import { toast } from \"react-hot-toast\";\n// import { jwtDecode } from \"jwt-decode\";\n\n// const AuthContext = createContext();\n\n// const isTokenValid = (token) => {\n//   if (!token) return false;\n//   try {\n//     const decoded = jwtDecode(token);\n//     return decoded.exp * 1000 > Date.now();\n//   } catch (error) {\n//     return false;\n//   }\n// };\n\n// const token = localStorage.getItem(\"token\");\n// const user = token && isTokenValid(token) ? jwtDecode(token).user : null;\n\n// const initialState = {\n//   token: token,\n//   user: user,\n//   isAuthenticated: !!user,\n//   loading: false,\n//   error: null,\n// };\n\n// const AUTH_ACTIONS = {\n//   REQUEST_START: \"REQUEST_START\",\n//   AUTH_SUCCESS: \"AUTH_SUCCESS\",\n//   AUTH_FAILURE: \"AUTH_FAILURE\",\n//   LOGOUT: \"LOGOUT\",\n//   CLEAR_ERRORS: \"CLEAR_ERRORS\",\n// };\n\n// const authReducer = (state, action) => {\n//   switch (action.type) {\n//     case AUTH_ACTIONS.REQUEST_START:\n//       return { ...state, loading: true, error: null };\n//     case AUTH_ACTIONS.AUTH_SUCCESS:\n//       const newUser = jwtDecode(action.payload.token).user;\n//       localStorage.setItem(\"token\", action.payload.token);\n//       return {\n//         ...state,\n//         token: action.payload.token,\n//         user: newUser,\n//         isAuthenticated: true,\n//         loading: false,\n//         error: null,\n//       };\n//     case AUTH_ACTIONS.AUTH_FAILURE:\n//     case AUTH_ACTIONS.LOGOUT:\n//       localStorage.removeItem(\"token\");\n//       return {\n//         ...state,\n//         token: null,\n//         user: null,\n//         isAuthenticated: false,\n//         loading: false,\n//         error: action.payload,\n//       };\n//     case AUTH_ACTIONS.CLEAR_ERRORS:\n//       return { ...state, error: null };\n//     default:\n//       return state;\n//   }\n// };\n\n// export const AuthProvider = ({ children }) => {\n//   const [state, dispatch] = useReducer(authReducer, initialState);\n\n//   const login = useCallback(async (email, password) => {\n//     dispatch({ type: AUTH_ACTIONS.REQUEST_START });\n//     try {\n//       const response = await axios.post(\"/api/auth/login\", { email, password });\n//       dispatch({\n//         type: AUTH_ACTIONS.AUTH_SUCCESS,\n//         payload: { token: response.data.token },\n//       });\n//       toast.success(\"Logged in successfully!\");\n//       return { success: true };\n//     } catch (error) {\n//       const errorMessage = error.response?.data?.msg || \"Login failed\";\n//       dispatch({ type: AUTH_ACTIONS.AUTH_FAILURE, payload: errorMessage });\n//       toast.error(errorMessage);\n//       return { success: false, error: errorMessage };\n//     }\n//   }, []);\n\n//   const register = useCallback(async (userData) => {\n//     dispatch({ type: AUTH_ACTIONS.REQUEST_START });\n//     try {\n//       const response = await axios.post(\"/api/auth/register\", userData);\n//       dispatch({\n//         type: AUTH_ACTIONS.AUTH_SUCCESS,\n//         payload: { token: response.data.token },\n//       });\n//       toast.success(\"Account created successfully!\");\n//       return { success: true };\n//     } catch (error) {\n//       const errorMessage = error.response?.data?.msg || \"Registration failed\";\n//       dispatch({ type: AUTH_ACTIONS.AUTH_FAILURE, payload: errorMessage });\n//       toast.error(errorMessage);\n//       return { success: false, error: errorMessage };\n//     }\n//   }, []);\n\n//   const logout = useCallback(() => {\n//     dispatch({ type: AUTH_ACTIONS.LOGOUT, payload: null });\n//     toast.success(\"Logged out successfully!\");\n//   }, []);\n\n//   const clearErrors = useCallback(() => {\n//     dispatch({ type: AUTH_ACTIONS.CLEAR_ERRORS });\n//   }, []);\n\n//   useEffect(() => {\n//     if (state.token) {\n//       axios.defaults.headers.common[\"Authorization\"] = `Bearer ${state.token}`;\n//     } else {\n//       delete axios.defaults.headers.common[\"Authorization\"];\n//     }\n//   }, [state.token]);\n\n//   const value = useMemo(\n//     () => ({ ...state, login, register, logout, clearErrors }),\n//     [state, login, register, logout, clearErrors],\n//   );\n\n//   return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n// };\n\n// export const useAuth = () => {\n//   const context = useContext(AuthContext);\n//   if (!context) {\n//     throw new Error(\"useAuth must be used within an AuthProvider\");\n//   }\n//   return context;\n// };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}